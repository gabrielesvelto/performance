\begin{frame}
 \frametitle{Computational Complexity}
 \begin{itemize}
  \item Given
   \begin{itemize}
    \item Algorithm
    \item Input of length \( n \)
   \end{itemize}
  \item How many steps are necessary to complete algorithm as \( n \rightarrow \infty \)?
 \end{itemize}
\end{frame}

\begin{frame}
 \frametitle{Big-O Notation}
 \begin{itemize}
  \item \( algorithm(n) = O(steps(n)) \) as \(n \rightarrow \infty \)
  \item Typical results
   \begin{description}
    \item[\(O(1)\)] constant complexity, sign function, absolute values
    \item[\(O(logn)\)] logarithmic complexity, binary searches
    \item[\(O(n)\)] linear complexity, linear searching
    \item[\(O(nlogn)\)] linearithmic complexity, building search trees \\ \hfill \\
    \item[\(O(n^k)\)] polynomial complexity, naive sorting (e.g, bubble sort), matrix multiplication \\ \hfill \\
    \item[\(O(k^n)\)] exponential complexity, traveling salesman problem
   \end{description}
 \end{itemize}
\end{frame}

\begin{frame}
 \frametitle{Determining Complexity}
 \begin{itemize}
  \item use standard algorithms with known complexity
 \end{itemize}

 or

 \begin{itemize}
  \item try to describe relation between \( n \) and number of primitive operations
  \item example of bubble sort
  \begin{enumerate}
   \item \(n\) iterations
   \item first iteration: \( n-1 \) compare operations
   \item second iteration: \( n-2 \) compare operations
   \item \(n'th\) iteration: \( n-n = 0 \) compare operations
   \item average per iteration: \( n/2 \) compare operations
   \item overall complexity: \( O(n * n/2) = O(n^2 / 2) = O(n^2) \)
  \end{enumerate}
  \item combinations of algorithms have the maximum complexity of primitive algorithms
  \item example of bubble-sorting absolute values
  \begin{enumerate}
   \item walk over all elements (\( O(n) \))
   \begin{itemize}
    \item compute absolute value for each element (\( O(1) \))
   \end{itemize}
   \item bubble-sort the results (\( O(n^2) \))
   \item overall complexity: \( O(n*1 + n^2) = O(n^2) \)
  \end{enumerate}
 \end{itemize}
\end{frame}

\begin{frame}
 \frametitle{Which algorithms are best?}
 \begin{itemize}
  \item naive answer: use algorithm with lowest complexity
  \begin{itemize}
   \item if \(n\) is sufficiently large
   \item if you're going to re-use the result (e.g., build a search tree for multiple searches)
  \end{itemize}
  \item but there are exceptions
  \begin{itemize}
   \item better algorithms come with setup costs (e.g., binary searches need sorted input)
   \item hardware has branch prediction and is optimized for linear memory access (by prefetching memory)
   \begin{itemize}
    \item binary searches hop around in elements
    \item linear searches will walk over elements
   \end{itemize}
  \end{itemize}
 \end{itemize}
\end{frame}
